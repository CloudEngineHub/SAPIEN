import numpy
from numpy import float32, int32
from numpy import array
from typing import Any, List


class pybind11_object(object): ...


class ArticulationJointType(pybind11_object):
    PRISMATIC: Any = ...
    REVOLUTE: Any = ...
    SPHERICAL: Any = ...
    FIX: Any = ...
    UNDEFINED: Any = ...


class ActorType(pybind11_object):
    STATIC: Any = ...
    KINEMATIC: Any = ...
    DYNAMIC: Any = ...
    LINK: Any = ...
    KINEMATIC_LINK: Any = ...


class ArticulationType(pybind11_object):
    DYNAMIC: Any = ...
    KINEMATIC: Any = ...


class SolverType(pybind11_object):
    PGS: Any = ...
    TGS: Any = ...


class PxMaterial(pybind11_object):
    def get_static_friction(self) -> float: ...
    def get_dynamic_friction(self) -> float: ...
    def get_restitution(self) -> float: ...
    def set_static_friction(self, coef: float) -> None: ...
    def set_dynamic_friction(self, coef: float) -> None: ...
    def set_restitution(self, coef: float) -> None: ...


class Pose(pybind11_object):
    p: numpy.ndarray[float32] = ...
    q: numpy.ndarray[float32] = ...
    def inv(self) -> Pose: ...
    def transform(self, arg0: Pose) -> Pose: ...
    def set_p(self, p: numpy.ndarray[float32]) -> None: ...
    def set_q(self, q: numpy.ndarray[float32]) -> None: ...


class IPxrRenderer(pybind11_object): ...


class IPxrScene(pybind11_object): ...


class ISensor(pybind11_object):
    def setInitialPose(self, pose: Pose) -> None: ...
    def getPose(self) -> Pose: ...
    def setPose(self, pose: Pose) -> None: ...


class ICamera(ISensor):
    def get_name(self) -> str: ...
    def get_width(self) -> int: ...
    def get_height(self) -> int: ...
    def get_fovy(self) -> float: ...
    def take_picture(self) -> None: ...
    def get_color_rgba(self) -> numpy.ndarray[float32]: ...
    def get_albedo_rgba(self) -> numpy.ndarray[float32]: ...
    def get_normal_rgba(self) -> numpy.ndarray[float32]: ...
    def get_depth(self) -> numpy.ndarray[float32]: ...
    def get_segmentation(self) -> numpy.ndarray[int32]: ...
    def get_obj_segmentation(self) -> numpy.ndarray[int32]: ...


class OptifuserRenderer(IPxrRenderer):
    def enable_global_axes(self, enable: bool = True) -> None: ...
    @staticmethod
    def set_default_shader_config(glsl_dir: str, glsl_version: str) -> None: ...


class Input(pybind11_object):
    def get_key_state(self, arg0: int) -> int: ...
    def get_key_down(self, arg0: int) -> int: ...
    def get_key_mods(self, arg0: int) -> int: ...


class OptifuserController(pybind11_object):
    input: Input = ...
    should_quit: bool = ...
    def show_window(self) -> None: ...
    def hide_window(self) -> None: ...
    def set_current_scene(self, scene: Scene) -> None: ...
    def render(self) -> None: ...
    def set_camera_position(self, x: float, y: float, z: float) -> None: ...
    def set_camera_rotation(self, yaw: float, pitch: float) -> None: ...
    def get_camera_pose(self) -> Pose: ...
    def focus(self, actor: ActorBase) -> None: ...
    def get_selected_actor(self) -> ActorBase: ...


class CameraSpec(pybind11_object):
    name: str = ...
    aspect: float = ...
    fovy: float = ...
    near: float = ...
    far: float = ...
    position: numpy.ndarray[float32] = ...
    rotation: numpy.ndarray[float32] = ...
    def set_position(self, position: numpy.ndarray[float32]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[float32]) -> None: ...
    def lookAt(self, direction: numpy.ndarray[float32], up: numpy.ndarray[float32]) -> None: ...
    def get_model_matrix(self) -> numpy.ndarray[float32]: ...
    def get_projection_matrix(self) -> numpy.ndarray[float32]: ...


class FPSCameraSpec(CameraSpec):
    def update(self) -> None: ...
    def is_sane(self) -> bool: ...
    def set_forward(self, forward: numpy.ndarray[float32]) -> None: ...
    def set_up(self, up: numpy.ndarray[float32]) -> None: ...
    def rotate_yaw_pitch(self, delta_yaw: float, delta_pitch: float) -> None: ...
    def move_forward_right(self, delta_forward: float, delta_right: float) -> None: ...
    def get_rotation0(self) -> numpy.ndarray[float32]: ...


class OptifuserCamera(CameraSpec, ICamera):
    def get_camera_matrix(self) -> numpy.ndarray[float32]: ...


class Engine(pybind11_object):
    def set_renderer(self, renderer: IPxrRenderer) -> None: ...
    def get_renderer(self) -> IPxrRenderer: ...
    def create_physical_material(self, arg0: float, arg1: float, arg2: float) -> PxMaterial: ...
    def create_scene(self, gravity: numpy.ndarray[float32] = array([0., 0., -9.8], dtype=float32), solver_type: SolverType = SolverType.PGS, enable_ccd: bool = False, enable_pcm: bool = False) -> Scene: ...


class Scene(pybind11_object):
    name: str = ...
    timestep: float = ...
    def set_timestep(self, second: float) -> None: ...
    def get_timestep(self) -> float: ...
    def create_actor_builder(self) -> ActorBuilder: ...
    def create_articulation_builder(self) -> ArticulationBuilder: ...
    def create_urdf_loader(self: Scene) -> URDFLoader: ...
    def remove_actor(self, actor: ActorBase) -> None: ...
    def remove_articulation(self, articulation: Articulation) -> None: ...
    def remove_kinematic_articulation(self, kinematic_articulation: KinematicArticulation) -> None: ...
    def find_actor_by_id(self, id: int) -> ActorBase: ...
    def find_articulation_link_by_link_id(self, id: int) -> LinkBase: ...
    def add_mounted_camera(self, name: str, actor: ActorBase, pose: Pose, width: int, height: int, fovx: float, fovy: float, near: float, far: float) -> ICamera: ...
    def get_mounted_cameras(self) -> List[ICamera]: ...
    def get_mounted_actors(self) -> List[ActorBase]: ...
    def remove_mounted_camera(self, camera: ICamera) -> None: ...
    def find_mounted_camera(self, name: str, actor: ActorBase = None) -> ICamera: ...
    def step(self) -> None: ...
    def update_render(self) -> None: ...
    def add_ground(self, altitude: float, render: bool = True, material: PxMaterial = None) -> None: ...
    def get_contacts(self) -> List[Contact]: ...
    def set_shadow_light(self, direction: numpy.ndarray[float32], color: numpy.ndarray[float32]) -> None: ...
    def set_ambient_light(self, clor: numpy.ndarray[float32]) -> None: ...
    def add_point_light(self, position: numpy.ndarray[float32], color: numpy.ndarray[float32]) -> None: ...
    def add_directional_light(self, direction: numpy.ndarray[float32], color: numpy.ndarray[float32]) -> None: ...
    def get_renderer_scene(self) -> IPxrScene: ...
    def create_drive(self, actor1: ActorBase, pose1: Pose, actor2: ActorBase, pose2: Pose) -> Drive: ...


class Drive(pybind11_object):
    def set_properties(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, is_acceleration: bool = True) -> None: ...
    def set_target(self, pose: Pose) -> None: ...
    def set_target_velocity(self, linear: numpy.ndarray[float32], angular: numpy.ndarray[float32]) -> None: ...
    def destroy(self) -> None: ...


class ActorBase(pybind11_object):
    name: str = ...
    type: ActorType = ...
    id: int = ...
    pose: Pose = ...
    col1: int = ...
    col2: int = ...
    col3: int = ...
    def get_name(self) -> str: ...
    def set_name(self, name: str) -> None: ...
    def get_id(self) -> int: ...
    def get_scene(self) -> Scene: ...
    def get_pose(self) -> Pose: ...


class ActorDynamicBase(ActorBase):
    velocity: numpy.ndarray[float32] = ...
    angular_velocity: numpy.ndarray[float32] = ...
    mass: float = ...
    inertia: numpy.ndarray[float32] = ...
    cmass_local_pose: Pose = ...
    def get_velocity(self) -> numpy.ndarray[float32]: ...
    def get_angular_velocity(self) -> numpy.ndarray[float32]: ...
    def get_mass(self) -> float: ...
    def get_inertia(self) -> numpy.ndarray[float32]: ...
    def get_cmass_local_pose(self) -> Pose: ...
    def add_force_at_point(self, force: numpy.ndarray[float32], point: numpy.ndarray[float32]) -> None: ...
    def add_force_torque(self, force: numpy.ndarray[float32], torque: numpy.ndarray[float32]) -> None: ...
    def set_damping(self, linear: float, angular: float) -> None: ...


class ActorStatic(ActorBase):
    def set_pose(self, pose: Pose) -> None: ...
    def pack(self) -> List[float]: ...
    def unpack(self, arg0: numpy.ndarray[float32]) -> None: ...


class Actor(ActorDynamicBase):
    def set_pose(self, pose: Pose) -> None: ...
    def set_velocity(self, arg0: numpy.ndarray[float32]) -> None: ...
    def set_angular_velocity(self, arg0: numpy.ndarray[float32]) -> None: ...
    def pack(self) -> List[float]: ...
    def unpack(self, arg0: numpy.ndarray[float32]) -> None: ...


class LinkBase(ActorDynamicBase):
    def get_index(self) -> int: ...
    def get_articulation(self) -> ArticulationBase: ...


class Link(LinkBase):
    def get_articulation(self) -> Articulation: ...


class KinematicLink(LinkBase):
    def get_articulation(self) -> KinematicArticulation: ...


class JointBase(pybind11_object):
    name: str = ...
    def get_name(self) -> str: ...
    def set_name(self, name: str) -> None: ...
    def get_parent_link(self) -> LinkBase: ...
    def get_child_link(self) -> LinkBase: ...
    def get_dof(self) -> int: ...
    def get_limits(self) -> numpy.ndarray[float32]: ...
    def set_limits(self, limits: numpy.ndarray[float32]) -> None: ...


class Joint(JointBase):
    def set_friction(self, friction: float) -> None: ...
    def set_drive_property(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38) -> None: ...
    def set_drive_velocity_target(self, velocity: float) -> None: ...
    def set_drive_target(self, target: float) -> None: ...
    def get_global_pose(self) -> Pose: ...


class KinematicJoint(JointBase): ...
class KinematicJointFixed(KinematicJoint): ...
class KinematicJointSingleDof(KinematicJoint): ...
class KinematicJointPrismatic(KinematicJointSingleDof): ...
class KinematicJointRevolute(KinematicJointSingleDof): ...


class ArticulationBase(pybind11_object):
    name: str = ...
    type: ArticulationType = ...
    dof: int = ...
    pose: Pose = ...
    def get_name(self) -> str: ...
    def set_name(self, name: str) -> None: ...
    def get_base_links(self) -> List[LinkBase]: ...
    def get_base_joints(self) -> List[JointBase]: ...
    def get_qpos(self) -> numpy.ndarray[float32]: ...
    def set_qpos(self, qpos: numpy.ndarray[float32]) -> None: ...
    def get_qvel(self) -> numpy.ndarray[float32]: ...
    def set_qvel(self, qvel: numpy.ndarray[float32]) -> None: ...
    def get_qacc(self) -> numpy.ndarray[float32]: ...
    def set_qacc(self, qacc: numpy.ndarray[float32]) -> None: ...
    def get_qf(self) -> numpy.ndarray[float32]: ...
    def set_qf(self, qf: numpy.ndarray[float32]) -> None: ...
    def get_qlimits(self) -> numpy.ndarray[float32]: ...
    def set_qlimits(self, qlimits: numpy.ndarray[float32]) -> None: ...
    def get_root_pose(self) -> Pose: ...
    def get_pose(self) -> Pose: ...
    def set_root_pose(self, pose: Pose) -> None: ...
    def set_pose(self, pose: Pose) -> None: ...


class ArticulationDrivable(ArticulationBase):
    def get_drive_target(self) -> numpy.ndarray[float32]: ...
    def set_drive_target(self, drive_target: numpy.ndarray[float32]) -> None: ...


class Articulation(ArticulationDrivable):
    def get_links(self) -> List[Link]: ...
    def get_joints(self) -> List[Joint]: ...
    def set_root_velocity(self, vel: numpy.ndarray[float32]) -> None: ...
    def set_root_angular_velocity(self, vel: numpy.ndarray[float32]) -> None: ...
    def compute_passive_force(self, gravity: bool = True, coriolisAndCentrifugal: bool = True, external: bool = True) -> numpy.ndarray[float32]: ...
    def compute_jacobian(self) -> numpy.ndarray[float32]: ...
    def pack(self) -> List[float]: ...
    def unpack(self, arg0: numpy.ndarray[float32]) -> None: ...


class KinematicArticulation(ArticulationDrivable): ...


class Contact(pybind11_object):
    actor1: ActorBase = ...
    actor2: ActorBase = ...
    point: numpy.ndarray[float32] = ...
    normal: numpy.ndarray[float32] = ...
    impulse: numpy.ndarray[float32] = ...
    separation: float = ...


class ActorBuilder(pybind11_object):
    def add_convex_shape_from_file(self, filename: str, pose: Pose = Pose(), scale: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), material: PxMaterial = None, density: float = 1000) -> None: ...
    def add_multiple_convex_shapes_from_file(self, filename: str, pose: Pose = Pose(), scale: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), material: PxMaterial = None, density: float = 1000) -> None: ...
    def add_decomposed_convex_shapes_from_file(self, filename: str, pose: Pose = Pose(), scale: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), material: PxMaterial = None, density: float = 1000) -> None: ...
    def add_box_shape(self, pose: Pose = Pose(), size: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), material: PxMaterial = None, density: float = 1000) -> None: ...
    def add_capsule_shape(self, pose: Pose = Pose(), radius: float = 1, half_length: float = 1, material: PxMaterial = None, density: float = 1000) -> None: ...
    def add_sphere_shape(self, pose: Pose = Pose(), radius: float = 1, material: PxMaterial = None, density: float = 1000) -> None: ...
    def add_box_visual(self, pose: Pose = Pose(), size: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), color: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), name: str = '') -> None: ...
    def add_capsule_visual(self, pose: Pose = Pose(), radius: float = 1, half_length: float = 1, color: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), name: str = '') -> None: ...
    def add_sphere_visual(self, pose: Pose = Pose(), radius: float = 1, color: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), name: str = '') -> None: ...
    def add_visual_from_file(self, filename: str, pose: Pose = Pose(), scale: numpy.ndarray[float32] = array([1., 1., 1.], dtype=float32), name: str = '') -> None: ...
    def set_collision_group(self, arg0: int, arg1: int, arg2: int) -> None: ...
    def add_collision_group(self, arg0: int, arg1: int, arg2: int) -> None: ...
    def reset_collision_group(self) -> None: ...
    def set_mass_and_inertia(self, arg0: float, arg1: Pose, arg2: numpy.ndarray[float32]) -> None: ...
    def set_scene(self, arg0: Scene) -> None: ...
    def build(self, is_kinematic: bool = False, name: str = '') -> Actor: ...
    def build_static(self, name: str = '') -> ActorStatic: ...


class LinkBuilder(ActorBuilder):
    def get_index(self) -> int: ...
    def set_parent(self, arg0: int) -> None: ...
    def set_name(self, arg0: str) -> None: ...
    def set_joint_name(self, arg0: str) -> None: ...
    def set_joint_properties(self, joint_type: ArticulationJointType, limits: numpy.ndarray[float32], parent_pose: Pose = Pose(), child_pose: Pose = Pose(), friction: float = 0, damping: float = 0) -> None: ...


class ArticulationBuilder(pybind11_object):
    def set_scene(self, scene: Scene) -> None: ...
    def get_scene(self) -> Scene: ...
    def create_link_builder(self, parent: LinkBuilder = None) -> LinkBuilder: ...
    def build(self, fix_base: bool = False) -> Articulation: ...
    def build_kinematic(self) -> KinematicArticulation: ...


class URDFLoader(pybind11_object):
    fix_root_link: bool = ...
    collision_is_visual: bool = ...
    scale: float = ...
    default_density: float = ...
    def load(self, filename: str, material: PxMaterial = None) -> Articulation: ...
    def load_kinematic(self, filename: str, material: PxMaterial = None) -> KinematicArticulation: ...
